import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { UserRole } from '@/lib/api/auth';
import { requireAuth, requireRole } from '@/lib/api/auth';
import { NotFoundError, ValidationError } from '@/lib/api/errors';
import { 
  logRequest, 
  rateLimit, 
  sanitizeRequestData, 
  validateRequest, 
  withMiddleware 
} from '@/lib/api/middleware';
import { errorResponse, successResponse } from '@/lib/api/response';
import { ApiResponse, HttpStatus } from '@/lib/api/types';
import { 
  CreateUserData, 
  PaginatedUsers, 
  User, 
  UserStatus, 
  createUserSchema,
  paginationSchema
} from '@/types/user';

// Mock users data (in a real app, this would come from a database)
const mockUsers: User[] = [
  {
    id: '1',
    email: 'admin@example.com',
    name: 'Admin User',
    role: UserRole.ADMIN,
    status: UserStatus.ACTIVE,
    createdAt: '2025-01-01T00:00:00Z',
    updatedAt: '2025-01-01T00:00:00Z',
    lastLogin: '2025-05-19T12:00:00Z',
  },
  {
    id: '2',
    email: 'teacher@example.com',
    name: 'Teacher User',
    role: UserRole.TEACHER,
    status: UserStatus.ACTIVE,
    createdAt: '2025-01-02T00:00:00Z',
    updatedAt: '2025-01-02T00:00:00Z',
    lastLogin: '2025-05-18T10:30:00Z',
  },
  {
    id: '3',
    email: 'student@example.com',
    name: 'Student User',
    role: UserRole.STUDENT,
    status: UserStatus.ACTIVE,
    createdAt: '2025-01-03T00:00:00Z',
    updatedAt: '2025-01-03T00:00:00Z',
    lastLogin: '2025-05-17T14:45:00Z',
  },
  {
    id: '4',
    email: 'parent@example.com',
    name: 'Parent User',
    role: UserRole.PARENT,
    status: UserStatus.ACTIVE,
    createdAt: '2025-01-04T00:00:00Z',
    updatedAt: '2025-01-04T00:00:00Z',
    lastLogin: '2025-05-16T08:15:00Z',
  },
  {
    id: '5',
    email: 'staff@example.com',
    name: 'Staff User',
    role: UserRole.STAFF,
    status: UserStatus.ACTIVE,
    createdAt: '2025-01-05T00:00:00Z',
    updatedAt: '2025-01-05T00:00:00Z',
    lastLogin: '2025-05-15T16:20:00Z',
  },
  {
    id: '6',
    email: 'inactive@example.com',
    name: 'Inactive User',
    role: UserRole.STUDENT,
    status: UserStatus.INACTIVE,
    createdAt: '2025-01-06T00:00:00Z',
    updatedAt: '2025-01-06T00:00:00Z',
  },
];

/**
 * Mock database function to list users with pagination and filtering
 * In a real app, this would query the database
 */
async function findUsers(params: {
  page: number;
  pageSize: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  search?: string;
  role?: UserRole;
  status?: UserStatus;
}): Promise<PaginatedUsers> {
  const { page, pageSize, sortBy = 'createdAt', sortOrder = 'desc', search, role, status } = params;
  
  // Apply filters
  let filteredUsers = [...mockUsers];
  
  if (search) {
    const searchLower = search.toLowerCase();
    filteredUsers = filteredUsers.filter(
      user => 
        user.name.toLowerCase().includes(searchLower) || 
        user.email.toLowerCase().includes(searchLower)
    );
  }
  
  if (role) {
    filteredUsers = filteredUsers.filter(user => user.role === role);
  }
  
  if (status) {
    filteredUsers = filteredUsers.filter(user => user.status === status);
  }
  
  // Apply sorting
  filteredUsers.sort((a: any, b: any) => {
    if (sortOrder === 'asc') {
      return a[sortBy] > b[sortBy] ? 1 : -1;
    } else {
      return a[sortBy] < b[sortBy] ? 1 : -1;
    }
  });
  
  // Apply pagination
  const totalItems = filteredUsers.length;
  const totalPages = Math.ceil(totalItems / pageSize);
  const startIndex = (page - 1) * pageSize;
  const paginatedUsers = filteredUsers.slice(startIndex, startIndex + pageSize);
  
  return {
    users: paginatedUsers,
    pagination: {
      page,
      pageSize,
      totalPages,
      totalItems,
    },
  };
}

/**
 * Mock database function to create a user
 * In a real app, this would insert into the database
 */
async function createUser(userData: CreateUserData): Promise<User> {
  // Check if email already exists
  const existingUser = mockUsers.find(user => user.email === userData.email);
  if (existingUser) {
    throw new ValidationError('Email already exists', { email: 'This email is already in use' });
  }
  
  // In a real app, you would hash the password here
  // const hashedPassword = await bcrypt.hash(userData.password, 10);
  
  const now = new Date().toISOString();
  const newUser: User = {
    id: (mockUsers.length + 1).toString(), // In a real app, this would be generated by the database
    email: userData.email,
    name: userData.name,
    role: userData.role,
    status: userData.status || UserStatus.ACTIVE,
    profileImage: userData.profileImage,
    createdAt: now,
    updatedAt: now,
  };
  
  // In a real app, you would save to the database here
  // await db.users.create(newUser);
  
  // For mock purposes, add to our array
  mockUsers.push(newUser);
  
  return newUser;
}

/**
 * Rate limit configuration for admin API
 */
const adminApiRateLimit = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  maxRequests: 60, // 60 requests per minute
});

/**
 * GET handler for listing users
 */
async function getUsersHandler(
  req: NextRequest,
  context: any
): Promise<NextResponse<ApiResponse<PaginatedUsers>>> {
  try {
    // Parse and validate query parameters
    const url = new URL(req.url);
    const queryParams: Record<string, string> = {};
    url.searchParams.forEach((value, key) => { 
      queryParams[key] = value;
    });
    
    // Validate query parameters using the pagination schema
    const validationResult = paginationSchema.safeParse(queryParams);
    
    if (!validationResult.success) {
      return errorResponse(
        new ValidationError('Invalid query parameters', validationResult.error.format()),
        HttpStatus.BAD_REQUEST
      );
    }
    
    // Get users with pagination and filtering
    const users = await findUsers(validationResult.data);
    
    // Return successful response with users
    return successResponse<PaginatedUsers>(
      users,
      {
        timestamp: new Date().toISOString(),
        requestId: context.requestId,
      },
      HttpStatus.OK
    );
  } catch (error) {
    // Let the error handling middleware take care of errors
    throw error;
  }
}

/**
 * POST handler for creating a new user
 */
async function createUserHandler(
  req: NextRequest,
  context: { data: CreateUserData }
): Promise<NextResponse<ApiResponse<User>>> {
  try {
    // Extract validated data from context (added by validation middleware)
    const userData = context.data;
    
    // Sanitize input data to prevent XSS
    const sanitizedData = sanitizeRequestData(userData);
    
    // Create the user
    const newUser = await createUser(sanitizedData);
    
    // Return successful response with created user
    return successResponse<User>(
      newUser,
      {
        timestamp: new Date().toISOString(),
        requestId: context.requestId,
      },
      HttpStatus.CREATED
    );
  } catch (error) {
    // Let the error handling middleware take care of errors
    throw error;
  }
}

/**
 * GET handler for listing users
 */
export async function GET(req: NextRequest): Promise<NextResponse> {
  return withMiddleware<PaginatedUsers>(
    getUsersHandler,
    [
      logRequest({ logLevel: 'info', includeHeaders: true }), // Log the request
      adminApiRateLimit, // Apply rate limiting
      requireAuth(), // Check if user is authenticated
      requireRole([UserRole.ADMIN]), // Check if user has admin role
    ]
  )(req, {});
}

/**
 * POST handler for creating a new user
 */
export async function POST(req: NextRequest): Promise<NextResponse> {
  return withMiddleware<User>(
    createUserHandler,
    [
      logRequest({ logLevel: 'info' }), // Log the request
      adminApiRateLimit, // Apply rate limiting
      requireAuth(), // Check if user is authenticated
      requireRole([UserRole.ADMIN]), // Check if user has admin role
      validateRequest<CreateUserData>(createUserSchema), // Validate request body
    ]
  )(req, {});
}

